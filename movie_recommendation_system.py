# -*- coding: utf-8 -*-
"""MOVIE RECCOMENDTION SYSTEMipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NORrM5BDVOF8ptCPx5nZ1CVDmTrnUHEt

3 TYPES OF RECCOMMENDATION SYSTEM:

1) CONTENT BASED

2) POPULARITY BASED

3) COLLABORATIVE BASED

WE WILL BE WORKING WITH THE CONTENT BASED SYSTEM ALONG WITH A FEW ASPECTS OF THE POPULARITY BASED SYSTEM

WORKFLOW:

1) DATA COLLECTION ---> 2) PREPROCESSING ---> 3) FEATURE EXTRACTION ---> 4) GENERATE SCORE FOR MOVIES ---> 5) USER WILL INPUT ---> 6) GIVE THEM RECOMMENDATION BASED ON "COSINE SIMILARITY ALGORITHM"

STARTING WITH IMPORTING DEPENDENCIES
"""

import pandas as pd
import numpy as np
import difflib #TO GET THE CLOSET MATCH FOR THE MOVIE THAT THE USER HAS ENTERED
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

"""DATA COLLECTION AND PREPROCESSING"""

# LOADING DATA FROM CSV TO PANDAS DF
movies_data = pd.read_csv('movies.csv')
movies_data.head()

# EXPLORING THE DATA FRAME A LITTLE
movies_data.shape

# SELECTING THE MOST RELEVANT FEATURES FROM ALL THE AVAILABLE FEATURES FOR A CONTENT BASES RECOMMENDATION SYSTEM
selected_features = ['genres','keywords','tagline','cast','director']

#REPLACING THE MISSING VALUES WITH A NULL STRING
for features in selected_features:
  movies_data[features] = movies_data[features].fillna('')

#COMBINING ALL THE 5 SELECTED FEATURES
combined_features = movies_data['genres'] + movies_data['keywords'] + movies_data['tagline'] + movies_data['cast']+ movies_data['director']
combined_features

# CONVERTING TEXT TO FEATURE VECTOR
vectorizer = TfidfVectorizer()
feature_vectors = vectorizer.fit_transform(combined_features)
print(feature_vectors)

"""NOW WE FIND THE SIMILARITY SCORE USING COSINE SIMILARITY"""

similarity = cosine_similarity(feature_vectors)

"""THE ABOVE LINE OF CODE TELLS US THE SIMILARITY BETWEEN EACH MOVIE WITH EACH AND EVERY OTHER MOVIE IN OUR LIST"""

# ASKING FOR INPUT FROM THE USER
movie_name = input('Enter A Movies Name:')

# CREATING A LIST OF ALL MOVIE NAMES IN THE DATA FRAME SO THAT WE CAN MATCH IT WITH THE MOVIE NAME GIVEN TO US
list_of_all_titles = movies_data['title'].tolist()
print(list_of_all_titles)

# FINDING THE CLOSET MATCH TO THE MOVIE NAME GIVEN TO US BY THE USER WE WILL USE DIFFLIB
find_close_match = difflib.get_close_matches(movie_name,list_of_all_titles)
print(find_close_match)

close_match = find_close_match[0]
print(close_match)

# NOW I'LL TRY TO FIND THE INDEX OF MY CLOSE_MATCH MOVIE IN MY DATASET
index_of_the_movie = movies_data[movies_data.title == close_match]['index'].iloc[0]
print(index_of_the_movie)

"""THE BELOW CODE GIVES US THE SIMILARITY SCORE OF EACH MOVIE WITH THE MOVIE THAT THE USER HAS ENTERED

"""

#GETTING THE LIST OF SIMILAR MOVIES
similarity_score = list(enumerate(similarity[index_of_the_movie]))
print(similarity_score)

"""WHAT DID THE ABOVE LINE OF CODE DID (NOTE TO SELF):

1) similarity[index_of_the_movie]

similarity is likely a 2D list (matrix) or a NumPy array representing similarity scores between movies.

2) index_of_the_movie refers to a specific movie's index.

similarity[index_of_the_movie] retrieves a row from the similarity matrix, which contains similarity scores of that movie with all other movies.

3) enumerate(similarity[index_of_the_movie])

enumerate() pairs each similarity score with its corresponding index (movie index).

4) list(enumerate(similarity[index_of_the_movie]))

Converts the enumerated object into a list of tuples where:
The first element in each tuple is the index (movie ID).
The second element is the similarity score between index_of_the_movie and that particular movie.
"""

#SORTING THE MOVIES BASED ON THEIR SIMILARITY SCORE
sorted_similar_movies = sorted(similarity_score,key=lambda x:x[1], reverse= True) #REVERSE = TRUE GIVES VALUES IN DESCENDING ORDER
print(sorted_similar_movies)

#PRINT THE NAMES OF THE SIMILAR MOVIES BASED ON THE INDEX
print('Movies Suggested for you:\n')

i =1
for movie in sorted_similar_movies:
  index = movie[0]
  title_from_index = movies_data[movies_data.index == index]['title'].values[0]
  if (i<=30):
    print(i, '.', title_from_index)
    i = i+1

